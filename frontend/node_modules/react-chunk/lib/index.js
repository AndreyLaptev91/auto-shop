'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require('react');
var PropTypes = require('prop-types');
var hoistNonReactStatics = require('hoist-non-react-statics');
var getDisplayName = require('react-display-name').default;
var invariant = require('invariant');

var ALL_INITIALIZERS = [];
var READY_INITIALIZERS = [];
var TIMEOUT_ERR = '_t';

function isWebpackReady(getModuleIds) {
  // eslint-disable-next-line no-undef
  if ((typeof __webpack_modules__ === 'undefined' ? 'undefined' : _typeof(__webpack_modules__)) !== 'object') {
    return false;
  }

  return getModuleIds().every(function (moduleId) {
    return typeof moduleId !== 'undefined' &&
    // eslint-disable-next-line no-undef
    typeof __webpack_modules__[moduleId] !== 'undefined';
  });
}

function retryLoader(resolve, reject, fn, retryOpts) {
  if (retryOpts.hasResolved) {
    return;
  }

  var invokeRetry = function invokeRetry(err) {
    var backOff = retryOpts.backOff;
    if (backOff.length) {
      var wait = backOff.shift();
      setTimeout(function () {
        return retryLoader(resolve, reject, fn, retryOpts);
      }, wait);
    } else if (err && !retryOpts.hasResolved) {
      retryOpts.hasResolved = true;
      reject(err);
    }
  };

  var _timeout = void 0;
  if (retryOpts.importTimeoutMs > 0) {
    _timeout = setTimeout(function () {
      return invokeRetry(retryOpts.throwOnImportError ? new Error(TIMEOUT_ERR) : null);
    }, retryOpts.importTimeoutMs);
  }

  fn().then(function (res) {
    clearTimeout(_timeout);

    if (!retryOpts.hasResolved) {
      retryOpts.hasResolved = true;
      resolve(res);
    }
  }).catch(function (err) {
    clearTimeout(_timeout);
    invokeRetry(err);
  });
}

function hasLoaded(state) {
  return !state.loading && !state.error && !!state.loaded;
}

function load(loader, options) {
  var promise = new Promise(function (resolve, reject) {
    retryLoader(resolve, reject, loader, {
      backOff: options.retryBackOff.slice(),
      importTimeoutMs: options.importTimeoutMs,
      throwOnImportError: options.throwOnImportError,
      hasResolved: false
    });
  });

  var state = {
    loading: true,
    loaded: null,
    error: null
  };

  state.promise = promise.then(function (loaded) {
    state.loading = false;
    state.loaded = loaded;
    return loaded;
  }).catch(function (err) {
    state.loading = false;
    state.error = err;
    throw err;
  });

  return state;
}

function loadMap(obj, options) {
  var state = {
    loading: false,
    loaded: {},
    error: null
  };

  var promises = [];

  try {
    Object.keys(obj).forEach(function (key) {
      var result = load(obj[key], options);

      if (!result.loading) {
        state.loaded[key] = result.loaded;
        state.error = result.error;
      } else {
        state.loading = true;
      }

      promises.push(result.promise);

      result.promise.then(function (res) {
        state.loaded[key] = res;
      }).catch(function (err) {
        state.error = err;
      });
    });
  } catch (err) {
    state.error = err;
  }

  state.promise = Promise.all(promises).then(function (res) {
    state.loading = false;
    return res;
  }).catch(function (err) {
    state.loading = false;
    throw err;
  });

  return state;
}

function resolve(obj) {
  return obj && obj.__esModule ? obj.default : obj;
}

function createChunkComponent(loadFn, options) {
  var opts = Object.assign({
    displayName: null,
    loader: null,
    hoistStatics: false,
    resolveDefaultImport: function resolveDefaultImport(imported /*, importKey */) {
      return resolve(imported);
    },
    retryBackOff: [],
    delay: 200,
    timeout: null,
    webpack: null,
    modules: []
  }, options);

  var res = null;
  var hoistSubscribers = [];
  var importedSubscribers = [];
  var importTimeoutMs = typeof opts.timeout === 'number' ? opts.timeout : 0;

  // Adjust the UI timeout to include the retry backOff options
  if (opts.retryBackOff.length && typeof opts.timeout === 'number') {
    opts.timeout = opts.retryBackOff.reduce(function (total, ms) {
      return total + ms;
    }, opts.timeout * opts.retryBackOff.length);
  }

  return function (WrappedComponent) {
    if (!opts.singleImport && typeof WrappedComponent === 'undefined') {
      throw new Error('`chunks({..})([missing])` requires a component to wrap.');
    }

    var ChunkComponent = function (_React$Component) {
      _inherits(ChunkComponent, _React$Component);

      function ChunkComponent(props) {
        _classCallCheck(this, ChunkComponent);

        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

        init(false);

        _this.state = {
          error: res.error,
          pastDelay: false,
          timedOut: false,
          loading: res.loading,
          loaded: res.loaded
        };
        return _this;
      }

      ChunkComponent.preloadChunk = function preloadChunk() {
        return init(true);
      };

      ChunkComponent.getChunkLoader = function getChunkLoader() {
        return init;
      };

      ChunkComponent.onImported = function onImported(importedHandler) {
        invariant(typeof importedHandler === 'function', '"onImported" expects a single function argument.');
        return ChunkComponent.bindImportSubscriber(importedHandler, importedSubscribers);
      };

      ChunkComponent.onImportedWithHoist = function onImportedWithHoist(hoistSubscriber) {
        invariant(typeof hoistSubscriber === 'function', '"onHoistImported" expects a single function argument.');

        if (!opts.hoistStatics) {
          // nothing to hoist
          return;
        }

        return ChunkComponent.bindImportSubscriber(hoistSubscriber, hoistSubscribers);
      };

      ChunkComponent.bindImportSubscriber = function bindImportSubscriber(handler, subscribers) {
        if (res && res.loaded) {
          handler(opts.resolveDefaultImport(res.loaded));
          return;
        }

        subscribers.push(handler);

        // return an unsubscribe function
        return function () {
          var idx = subscribers.indexOf(handler);
          if (idx !== -1) {
            return subscribers.splice(idx, 1);
          }
        };
      };

      ChunkComponent.prototype._loadChunks = function _loadChunks() {
        var _this2 = this;

        if (!res.loading) {
          return;
        }

        // clear timeouts - in case 'retry' is invoked before loading is complete
        this._clearTimeouts();

        if (typeof opts.delay === 'number') {
          if (opts.delay === 0) {
            this.setState({ pastDelay: true });
          } else {
            this._delay = setTimeout(function () {
              _this2.setState({ pastDelay: true });
            }, opts.delay);
          }
        }

        // This approach doesn't provide ms specific feedback, but implementation is really easy
        // - an alternative is to subscribe to: res.onTimeout(() => setState(...))
        // - if more accurate feedback is required, this can be implemented (w/'unsubscribe' on _clearTimeouts)
        if (typeof opts.timeout === 'number') {
          this._timeout = setTimeout(function () {
            _this2.setState({ timedOut: true });
          }, opts.timeout);
        }

        var update = function update() {
          hoistStatics();

          if (!_this2._mounted) {
            return;
          }

          _this2.setState({
            error: res.error,
            loaded: res.loaded,
            loading: res.loading
          });

          _this2._clearTimeouts();
        };

        res.promise.then(function () {
          update();
        }).catch(function () /* err */{
          update();
        });
      };

      ChunkComponent.prototype._clearTimeouts = function _clearTimeouts() {
        clearTimeout(this._delay);
        clearTimeout(this._timeout);
      };

      ChunkComponent.prototype.retry = function retry() {
        if (hasLoaded(this.state)) {
          return;
        }

        // reset state for retry
        res = null;
        this.setState({
          error: null,
          loading: true,
          loaded: {},
          pastDelay: false,
          timedOut: false
        });

        // attempt to load the chunk(s) again
        var promise = init(false); // don't throw on err - this component can not support hoist (or logically, it'd never get here)
        this._loadChunks(); // update this components state
        return promise;
      };

      ChunkComponent.prototype.componentWillMount = function componentWillMount() {
        var _this3 = this;

        this._mounted = true;

        if (this.props.chunks && Array.isArray(opts.modules)) {
          opts.modules.forEach(function (moduleName) {
            _this3.props.chunks.addChunk(moduleName);
          });
        }

        this._loadChunks();
      };

      ChunkComponent.prototype.componentWillUnmount = function componentWillUnmount() {
        this._mounted = false;
        this._clearTimeouts();
      };

      ChunkComponent.prototype.render = function render() {
        var _this4 = this;

        // eslint-disable-next-line no-unused-vars
        var _props = this.props,
            chunks = _props.chunks,
            passThroughProps = _objectWithoutProperties(_props, ['chunks']);

        var importState = {
          isLoading: this.state.loading,
          hasLoaded: hasLoaded(this.state),
          pastDelay: this.state.pastDelay,
          timedOut: this.state.timedOut,
          error: this.state.error,
          loaded: this.state.loaded,
          retry: function retry() {
            return _this4.retry();
          } // binds 'this'
        };

        if (opts.singleImport) {
          if (typeof WrappedComponent === 'undefined') {
            // no wrapped component
            if (importState.hasLoaded) {
              return React.createElement(opts.resolveDefaultImport(this.state.loaded), passThroughProps);
            }

            return null;
          }

          var _componentProps = Object.assign({}, passThroughProps, {
            chunk: _extends({}, importState, {
              importKeys: [],
              Imported: importState.hasLoaded ? opts.resolveDefaultImport(importState.loaded) : null
            })
          });

          return React.createElement(WrappedComponent, _componentProps);
        }

        var componentProps = Object.assign({}, passThroughProps, {
          chunk: _extends({}, importState, {
            importKeys: importState.hasLoaded ? Object.keys(this.state.loaded) : [],
            imported: {}
          })
        });

        if (importState.hasLoaded) {
          componentProps.chunk.imported = Object.keys(this.state.loaded).reduce(function (acc, importKey) {
            acc[importKey] = opts.resolveDefaultImport(_this4.state.loaded[importKey], importKey);
            return acc;
          }, componentProps.chunk.imported);
        }

        return React.createElement(WrappedComponent, componentProps);
      };

      return ChunkComponent;
    }(React.Component);

    // Apply chunks context to the chunk component


    ChunkComponent.propTypes = {
      chunks: PropTypes.shape({
        addChunk: PropTypes.func.isRequired
      })
    };
    var ChunkHOC = withChunks(ChunkComponent);

    var hasWrappedComponent = !(typeof WrappedComponent === 'undefined' || WrappedComponent === null);
    var wrappedComponentName = opts.displayName || (hasWrappedComponent ? getDisplayName(WrappedComponent) : '');
    ChunkHOC.displayName = opts.singleImport ? 'chunk(' + wrappedComponentName + ')' : 'chunks(' + wrappedComponentName + ')';

    var _hoisted = false;
    function hoistStatics() {
      if (_hoisted || !opts.hoistStatics) {
        return;
      }

      // Only hoist the static methods once
      if (!res.error && res.loaded && !_hoisted) {
        // Hoist is only supported by 'chunk'
        hoistNonReactStatics(ChunkHOC, opts.resolveDefaultImport(res.loaded));
        _hoisted = true;
      }
    }

    function init(throwOnImportError) {
      if (!res) {
        res = loadFn(opts.loader, {
          retryBackOff: Array.isArray(opts.retryBackOff) ? opts.retryBackOff : [],
          importTimeoutMs: importTimeoutMs,
          throwOnImportError: throwOnImportError
        });

        if (opts.hoistStatics) {
          res.promise = res.promise.then(function () {
            hoistStatics();
          }).catch(function (err) {
            // clear any subscribers on error
            if (hoistSubscribers.length !== 0) {
              hoistSubscribers.splice(0, hoistSubscribers.length);
            }

            if (importedSubscribers.length !== 0) {
              importedSubscribers.splice(0, importedSubscribers.length);
            }

            if (throwOnImportError === true) {
              // When pre-loading, any loader errors will be thrown immediately (ie: hoistStatics, timeout options)
              // - hoisting implies use of static methods, which need to be available prior to rendering.
              throw err;
            }
          }).then(function () {
            // Notify hoist subscribers
            if (hoistSubscribers.length !== 0) {
              var subscriberHandlers = hoistSubscribers.splice(0, hoistSubscribers.length);
              subscriberHandlers.forEach(function (subscribeHandler) {
                subscribeHandler(opts.resolveDefaultImport(res.loaded));
              });
            }
          });
        }

        // Notify 'onImported' subscribers
        res.promise = res.promise.then(function () {
          if (importedSubscribers.length !== 0) {
            var subscriberHandlers = importedSubscribers.splice(0, importedSubscribers.length);
            subscriberHandlers.forEach(function (subscribeHandler) {
              subscribeHandler(opts.resolveDefaultImport(res.loaded));
            });
          }
        });
      }

      return res.promise;
    }

    ALL_INITIALIZERS.push(init);

    if (typeof opts.webpack === 'function') {
      READY_INITIALIZERS.push(function (throwOnImportError) {
        if (isWebpackReady(opts.webpack)) {
          return init(throwOnImportError);
        }
      });
    }

    // Hoist any statics on the wrapped component
    return hasWrappedComponent ? hoistNonReactStatics(ChunkHOC, WrappedComponent) : ChunkHOC;
  };
}

function chunk(dynamicImport) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var webpackOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof dynamicImport !== 'function') {
    throw new Error('`chunk()` requires an import function.');
  }

  return createChunkComponent(load, _extends({}, webpackOpts, opts, { loader: dynamicImport, singleImport: true }));
}

function chunks(dynamicImport) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var webpackOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if ((typeof dynamicImport === 'undefined' ? 'undefined' : _typeof(dynamicImport)) !== 'object' || Array.isArray(dynamicImport) || dynamicImport === null) {
    throw new Error('`chunks()` requires a map of import functions.');
  }

  if (typeof opts.hoistStatics !== 'undefined') {
    throw new Error('`chunks()` does not support the "hoistStatics" option.');
  }

  return createChunkComponent(loadMap, _extends({}, webpackOpts, opts, { loader: dynamicImport, singleImport: false }));
}

function flushInitializers(initializers) {
  var promises = [];

  while (initializers.length) {
    var init = initializers.pop();
    promises.push(init(true));
  }

  return Promise.all(promises).then(function () {
    if (initializers.length) {
      return flushInitializers(initializers);
    }
  });
}

function preloadChunks(loaders) {
  return new Promise(function (resolve, reject) {
    return flushInitializers(loaders).then(resolve, reject);
  });
}

function preloadAll() {
  return preloadChunks(ALL_INITIALIZERS);
}

function preloadReady() {
  return preloadChunks(READY_INITIALIZERS);
}

function noop() {}

// HOC to access the chunks context
function withChunks(Component) {
  var ChunkReporter = function (_React$Component2) {
    _inherits(ChunkReporter, _React$Component2);

    function ChunkReporter() {
      _classCallCheck(this, ChunkReporter);

      return _possibleConstructorReturn(this, _React$Component2.apply(this, arguments));
    }

    ChunkReporter.prototype.render = function render() {
      var chunks = this.context.chunks;

      return React.createElement(Component, _extends({}, this.props, {
        chunks: {
          addChunk: chunks && chunks.addChunk || noop
        }
      }));
    };

    return ChunkReporter;
  }(React.Component);

  ChunkReporter.contextTypes = {
    chunks: PropTypes.shape({
      addChunk: PropTypes.func.isRequired
    })
  };


  return hoistNonReactStatics(ChunkReporter, Component);
}

exports.chunk = chunk;
exports.chunks = chunks;
exports.preloadReady = preloadReady;
exports.preloadAll = preloadAll;
exports.preloadChunks = preloadChunks;
exports.resolve = resolve;
exports.withChunks = withChunks;
exports.TIMEOUT_ERR = TIMEOUT_ERR;